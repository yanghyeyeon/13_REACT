<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id = "root"></div>


    <!-- 
        Hooks는 리엑트 16.8에서 도입된 기능으로, 함수형 컴포넌트에서 사용 불가능한
        생명주기 메소드의 한계점으로 인해 상태관리 및 렌더링 이후 시점 컨트롤 등, 다양한 문제를 해결하기
        위해 나온 함수 집합을 의미한다.
        
        컴포넌트가 렌더링 된 이후에 특정 작업을 수행할 필요가 있다면 클래스형 컴포넌트에서는
        componentDidMount 혹은 componentDidUpdate 메소드를 이용하면 된다.
        하지만 함수형 컴포넌트에는 생명주기 API를 사용할 수 없기 때문에, hooks를 제공하고 있고

        렌더링 이후 작업을 수행할 수 있게 해주는 useEffect가 있다.
    -->

    <script type = "text/babel">

        const {useEffect} = React;
        
        function MessagePrinter({message}) {
            // console.log(React);

            // const {message} = props;

            console.log(message);
            
            // props.message

            console.log('렌더링...');
            
            useEffect(() => {
                console.log('렌더링 이후 동작...');
                console.log(message);
                
            })

            return(
                <h1>{console.log('렌더링 시 출력...')}{message}</h1>
            )

            // 이 위치에서 (마운트 or 업데이트 이후에) 무언가 동작하게 하고 싶지만
            // 동작하지 않는다. (why? return  이후 코드라서)
            // 이 시점에서 실행하고 싶은것을 useEffect를 이용해서 처리할 수 있다.
            // console.log('렌더링 이후 동작...');
            
        }

        const message = '안녕하세요';

        ReactDOM.createRoot(document.getElementById('root')).render(<MessagePrinter message={message}/>);
    </script>
</body>
</html>